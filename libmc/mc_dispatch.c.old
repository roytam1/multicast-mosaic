/* Author: Gilles Dauphin [Jan98]
 *
 * See the file "license.mMosaic" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES. 
 */

#ifdef MULTICAST

#include <stdio.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <Xm/XmAll.h>

#include "../libnut/mipcf.h"
#include "../src/mosaic.h"
#include "mc_defs.h"

mo_window * 	mc_send_win;		/* if != NULL we are sending... */
int      	mc_multicast_enable;	/* mMosaic called with mc options */
unsigned int	mc_srcid;		/* SSRC for me */

			/* sockets */
int		mc_fd_rtp_w;
int		mc_fd_rtp_r;
int		mc_fd_rtcp_w;
int		mc_fd_rtcp_r;
int		uc_fd_rtp_w;
int		uc_fd_rtp_r;
int		uc_fd_rtcp_w;
int		uc_fd_rtcp_r;

			/* address and port . Net byte order*/
IPAddr		mc_rtp_addr_ip_group;
unsigned short	mc_rtp_port;
IPAddr		mc_rtcp_addr_ip_group;
unsigned short	mc_rtcp_port;
IPAddr		uc_rtp_addr_ip;
unsigned short	uc_rtp_port;
IPAddr		uc_rtcp_addr_ip;
unsigned short	uc_rtcp_port;

unsigned char	mc_ttl;

/*
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/param.h>
#include <signal.h>

#include "../libhtmlw/HTML.h"
#include "../libhtmlw/HTMLP.h"
#include "../src/gui-documents.h"
#include "mc_rtp.h"
#include "mc_misc.h"
#include "mc_sockio.h"
#include "mc_dispatch.h"
#include "mc_action.h"
#include "vir_cursor.xbm"

McSendDataStruct 	mc_data_send_data_struct;
XtIntervalId    	mc_send_rtcp_sdes_cname_time_out_id;

typedef struct _packet_struct {
	unsigned char code;
	IPAddr ipaddr;
	unsigned short pid;
	unsigned int url_id;
	unsigned int gmt_send_time;
	unsigned int nombre_eo;
	unsigned int num_eo;
	unsigned int seo;
	unsigned int nombre_packet;
	unsigned int num_packet;
	char * data;
	unsigned int packet_size;
	unsigned int nrecover;
} PacketStruct;

typedef int PacketsIndStruct ;

static XtInputId		mc_read_socket_id;
static XtInputId		mc_rtcp_read_socket_id;
static int 			NPacketToSend = 0;
static PacketStruct * 		Packets = NULL;
static PacketsIndStruct * 	Packets_ind = NULL;
static int			Number_of_Packets_ind = 0;
static XtIntervalId 		mc_send_all_data_in_bd_time_out_id;
static XtIntervalId 		mc_send_hear_beat_time_out_id;
static XtIntervalId 		mc_send_goto_id_time_out_id;
XtIntervalId		mc_check_senderstime_time_out_id;
XtIntervalId		mc_check_rcvstime_time_out_id;
Pixmap			VirCursorPix;
GC			gc_vc;

static unsigned long 		_mc_timer_interval=1000;
*/
/*
#define BAND_WIDTH (100000)	/* 100 Kb/s */

/*
McGlobalEo *		mc_global_embedded_object_tab= NULL;
unsigned int		mc_global_eo_count = 0 ;
int			mc_fdwrite;
int			mc_rtcp_fdwrite;
*/

/* initialisation of multicast datas structure */
/* called in gui.c after we open the first Mosaic window */
/* this start the multicast in listen mode only */
void McInit(mo_window * win)
{
	XGCValues gcv;
	unsigned long gcm;
	unsigned long fg;
	unsigned long bg;
	char * s;
	unsigned short port;

        mc_multicast_enable = 0;             
	if (mMosaicAppData.mc_dest == NULL)
		return;
	s = strchr(mMosaicAppData.mc_dest, '/');
	if (! *s){
		fprintf(stderr,"invalid Multicast addr/port\n");
		fprintf(stderr,"Multicast is disable\n");
		return;
	}

	*s = '\0';
	port = atoi(s+1);
	if (port%2!=0)
		port--;
	mc_rtp_port = htons(port);
	mc_rtcp_port = htons(port + 1);

	if (mMosaicAppData.mc_debug)
		printf("dest/port: %s/%d, ttl=%d\n",
			mMosaicAppData.mc_dest, port,
			mMosaicAppData.mc_ttl);
#ifdef IPV6
/* inet_pton () */
	if( ascii2addr(AF_INET6,mMosaicAppData.mc_dest,&mc_rtp_addr_ip_group) == -1){
		fprintf(stderr,"invalid IPV6Multicast addr\n");
		fprintf(stderr,"Multicast is disable\n");
		return;
	}
#else   
	mc_rtp_addr_ip_group = inet_addr(mMosaicAppData.mc_dest);
#endif                                 
	mc_multicast_enable = 1;
/* initialise global variable for Multicast */
	mc_debug = mMosaicAppData.mc_debug;
	mc_sess_name = mMosaicAppData.mc_sess_name;
	mc_media_name = mMosaicAppData.mc_media_name;
	mc_ttl = mMosaicAppData.mc_ttl;
        mc_alias_name = mMosaicAppData.author_email;
/*mc_dest become mc_rtp_addr_ip_group and mc_rtp_port */
	if( mMosaicAppData.mc_alias_name == NULL ){
		mc_alias_name = (char*) malloc(MC_MAX_SDES_NAME_LEN + 1);
		strncpy(mc_alias_name,mMosaicAppData.author_email,
			MC_MAX_SDES_NAME_LEN);
	} else {               
		mc_alias_name = mMosaicAppData.mc_alias_name;
	}                      
	if (strlen(mc_alias_name) >= MC_MAX_SDES_NAME_LEN )
		mc_alias_name[MC_MAX_SDES_NAME_LEN] = '\0';
	mc_len_alias = strlen(mc_alias_name);
	win->mc_type = MC_MO_TYPE_MAIN;
        mc_send_win = NULL;
	win->mc_callme_on_new_doc = NULL;
	win->mc_callme_on_new_object = NULL;;
/* choose an SSRC */
	mc_srcid = McGetSsrc();

/* open useable socket. There are 8 sockets we use:
 * - mc_fd_rtp_w:	(Multicast)
 *			We are a sender, emit data throught this channel
 *			At Init we are a listener, don't open at Init.
 *			Only sender open this channel.
 * - mc_fd_rtp_r:	(Multicast)
 *			We are a listener, data come from this channel.
 *			Play with data if we want them.
 * - uc_fd_rtp_w:	(Unicast)
 *			We are a sender, emit recover data throught this channel.
 *			This is a Unicast recover channel. When a listener
 *			ask for a recover, we send the data throught this channel.
 *			At Init we are a listener. Don't open...
 *			Only sender open this channel.
 * - uc_fd_rtp_r:	(Unicast)
 *			We are a listener, the recover data come from this channel
 *			A sender send those repair data only for me
 * - mc_fd_rtcp_w:	(Multicast)
 *			We are a sender, Send SR and some control throught
 *			this channel. A listener don't send report via multicast,
 *			A listener send report throught Unicast.
 *			At Init we are a listener. Don't open...
 *			Only sender open this channel.
 * - mc_fd_rtcp_r:	(Multicast)
 *			Only Sender Report come from this channel.
 *			Check all data.
 * - uc_fd_rtcp_w:	(Unicast)
 *			We are a listener. We send our (receiver) report throught
 *			this chanel. A sender that is not a receiver Never send
 *			data throught this channel.
 *			a listener that listen nothing send minimal data throught
 *			this channel (SDES-CNAME).
 * - uc_fd_rtcp_r:	(Unicast)
 *			We are a Sender. We receive report/repair from listener
 *			throught this channel.
 *			Only sender open this channel. At Init we are a listener.
 *			Don't open...
 * SUMARY:
 * A listener open:
	mc_fd_rtp_r	data from a sender
	uc_fd_rtp_r	data from a sender (Unicast) case of repair.
	mc_fd_rtcp_r	Sender Report from a sender.
	uc_fd_rtcp_w	Listener send report and ask for repair.
 * A listener DONT open:	 because
	mc_fd_rtp_w	We dont send data ...
	mc_fd_rtcp_w	Report via Unicast ...
	uc_fd_rtp_w	We dont send data ...
	uc_fd_rtcp_r	We dont receive report, because we are not a sender ...
 */
	mc_fd_rtp_w = -1;
	mc_fd_rtcp_w = -1;
	uc_fd_rtp_w = -1;
	uc_fd_rtcp_r = -1;

	mc_fd_rtp_r = McOpenRtpRead(mc_rtp_addr_ip_group,mc_rtp_port,mc_ttl);
	uc_fd_rtp_r = UcOpenRtpRead(&uc_rtp_r_addr_ip, &uc_rtp_r_port);
	mc_fd_rtcp_r = McOpenRtcpRead(mc_rtcp_addr_ip_group,mc_rtcp_port,mc_ttl);
/* open and bind */
	uc_fd_rtcp_r = UcOpenRtcpRead(&uc_rtcp_r_addr_ip, &uc_rtcp_r_port);
	uc_fd_rtcp_w = uc_fd_rtcp_r; /* we dont know yet where to send */
				/* we will know when a sender send cname */
/* kind of close */
	uc_fd_rtcp_r = -1;

	mc_rtp_r_input_id = XtAppAddInput(mMosaicAppContext, mc_fd_rtp_r,
		(XtPointer)XtInputReadMask, McRtpReadCb, NULL);
	uc_rtp_r_input_id = XtAppAddInput(mMosaicAppContext, uc_fd_rtp_r,
		(XtPointer)XtInputReadMask, UcRtpReadCb, NULL);
	mc_rtcp_r_input_id= XtAppAddInput(mMosaicAppContext,mc_fd_rtcp_r,
		(XtPointer)XtInputReadMask, McRtcpReadCb, NULL);
	uc_rtcp_w_sdes_timer_id = XtAppAddTimeOut(mMosaicAppContext,
		uc_rtcp_w_sdes_time, UcRtcpWriteSdesCb, NULL);
/*
REMARQUES:
	At Init time , we could receive packet from mc_rtp_r or mc_rtcp_r
	It is impossible to receive packet from uc_rtp_r.
	The UcRtcpWriteSdesCb callback will send data when he know
	where to send (if we know some sender target host)
*/
}

void McStartSender(mo_window * main_win)
{
	mc_send_win = main_win;
/* for collecting data */
	main_win->mc_callme_on_new_doc = McSendNewDoc;
	main_win->mc_callme_on_new_object = McSendNewObject;
	mc_local_url_id = -1;
	mc_send_doc_tab = NULL;	/* table of doc to send */
/* initialise sender part */
	mc_fd_rtp_w = McOpenRtpWrite(mc_rtp_addr_ip_group,mc_rtp_port,mc_ttl);
	mc_fd_rtcp_w = McOpenRtcpWrite(mc_rtcp_addr_ip_group, mc_rtcp_port,mc_ttl);
/* we reload, and via McSendNewDoc and McSendNewObject , on est prevenu
 * qu'une nouvelle doc ou objet est chargee */
	mo_reload_document (main_win->scrolled_win, main_win, NULL);
}

void McCreateDocEntry(char *fname, char* aurl_wa, MimeheaderStruct *mhs)
{
	i = mc_local_url_id;
	n_msentry = mc_local_url_id +1;
	if ( !msentry) { /* create multicast send entry */
		msentry = (MSEntry *)malloc(sizeof(MSEntry) *n_msentry );
	} else {
		msentry = (MSEntry *)realloc(msentry, sizeof(MSEntry) * n_msentry);
	}
	msentry[i].o_tab = (TABEntry*)malloc(sizeof(TABEntry) * 1);
	msentry[i].o_tab[0].h_part = ...
	msentry[i].o_tab[0].h_len = ...
	msentry[i].o_tab[0].h_fname = ...
	msentry[i].o_tab[0].d_part = ...
	msentry[i].o_tab[0].d_len = ...
	msentry[i].o_tab[0].d_fname = ...
	msentry[i].o_tab[0].o_num = 0;	/* numero de cet objet */
	msentry[i].o_tab[0].timestamp = timestamp;
	msentry[i].o_nobj = 1;		/* nombre d'objet */
}
void McScheduleSendDoc(int url_id)
{

	if (deb_plist) { /* il y a une file d'attente */
		/* volontary lost packet, un utilisateur va trop vite au regard
		 * de la bande passante qu'il s'autorise... */
		next_time = UnSchedule(deb_plist, end_plist);
	}

/* sedn the header in the first packet as a standalone packet */
}

####### case of navigation ###########
/* navigation in history never modify a doc or object... */
/* juste update the 'RTPtimestamp' in SR. Back to the futur... */
McSendOldDoc(...)
{
	DocEntry *doc_entry = NULL;

	doc_entry = IsDocStillSend(aurl, mhs);
	if ( doc_entry && ! reloading ) { /* dont resend */
		McRescheduleSR(doc_entry);
		return;
	}
}
#####################################

static void McSendNewObject(char *fname, char *aurl_wa, MimeHeaderStruct *mhs)
{
	if( IsObjStillInCurrentDoc(aurl) ) { /* we still send it in same doc */
		return;			/* don't resend */
	}
/* a new object */
	mc_local_object_id++;
	McCreateObjectEntry(fname, aurl, mhs);
	if ( obj_entry = IsObjStillSent(aurl,mhs) ) { /* we still sent this obj*/
			/* just reschedule SR. Un client est capable de
			 * determine si cette objet est dans son cache ou pas */
			/* send the header to help the client because */
			/* maybe we reload and modify this object */
		McScheduleSendHeaderOject(mc_local_object_id);
		return;
	}
	McScheduleSendOject(mc_local_object_id);
}
	mc_send_doc_struct.id = 0;
	mc_send_data_struct.text = NULL;
	mc_send_data_struct.neo = 0;
	mc_data_send_data_struct.is_send = 0;	/* is it send Once ? */
	mc_data_send_data_struct.win = mc_send_win;
	McFillData(&mc_data_send_data_struct,main_win);

	McSendAllDataOnlyOnce(&mc_data_send_data_struct);
	mc_send_hear_beat_time_out_id = XtAppAddTimeOut(
                                mMosaicAppContext,
                                MC_SEND_HEAR_BEAT_TIME_OUT,
                                McSendHearBeatTimeOutCb,
                                NULL);
	mc_send_goto_id_time_out_id = XtAppAddTimeOut(
                                mMosaicAppContext,
                                MC_SEND_GOTO_ID_TIME_OUT,
                                McSendGotoIdTimeOutCb,
                                NULL);

void McStopSendHyperText(mo_window * win)
{
	mc_send_win = NULL;
/* initialise sender part */
	mc_fd_rtp_w = ???;
	mc_fd_rtcp_w = ???;
	uc_fd_rtp_w = ???;
	uc_fd_rtcp_r = ???;
####
	mc_data_send_data_struct.id = 0;
	mc_local_url_id++;
	mc_data_send_data_struct.text = NULL;
	mc_data_send_data_struct.neo = 0;
	mc_data_send_data_struct.is_send = 0;
	mc_data_send_data_struct.win = NULL;
	XtRemoveTimeOut(mc_send_hear_beat_time_out_id);
	XtRemoveTimeOut(mc_send_goto_id_time_out_id);
}

/* il faut remplir une structure de donnee pour pouvoir
 * les multicaster plus tard...
 * Ceci est fait par McSendAllDataTimeOutCb
 * Cette structure doit etre rempli quand on a eu l'hypertexte
 * de facon 'normal' (par une connexion unicast) et qu'il est complet
 * (on a aussi les donnes 'images' ainsi que ses dimensions) c.a.d.
 * tout pour eviter une connexion unicast par le client qui recoit
 * les donnes multicasts. Au besoin modifier l'hyper-texte
 * pour completer les donnees manquantes (comme la taille d'une image GIF)
 */
void McFillData(McSendDataStruct * d, mo_window * win)
{
	int i;

	/* l'hypertext doit etre stocke en global qqe part */
	/* faut le trouver ... */

	/* parcourir htmlptr et selection de ce qui interesse */
	/* les mettre dans 'd'. Il suffit apres de balancer la puree */
	/* voir dans ImageResolve si on peut pas recuprer des donnes */
	/* liberer l'espace si alloue */

	/*d->id = ??? id de l'url ;	unsigned int	 */
	/*d->alias = l'email du mec ;	char *	 	*/
	/*d->url = l'url;		char *	 	*/
	/*d->text = l'hypertext;	char *	 	*/
	/*d->neo = nombre d'objet;	unsigned int 	 */
	/*d->seo = tableau de taile d'objet; unsigned int *	 */
	/*d->eos= tableau d'objet	char ** ou d->eos[i] = ???	 */
				/* eo[neo]. Each element is data of eo*/
                                /* but :                                */
                                /*    eo[0] <=> alias                   */
                                /*    eo[1] <=> URL                     */
                                /*    eo[1] <=> text                    */


/*###### */
	d->id = mc_local_url_id;
	d->alias = mc_alias_name;
	d->url = mc_local_url;
	d->is_send = 0;
	/* ajuste l'hyper texte pour en donner un autre avec les infos */
	/* en notre possession et connues (exemple IMG) */
	/* le resultat est dans d->text */
	/*if ( d->text != NULL) free(d->text);*/

	if (html_text_part){
		McAdjustText ( d);
		McGetEos( d);
	}

	if(Packets){
		for(i = 0; i< NPacketToSend; i++)
			free(Packets[i].data);
		free(Packets);
	}
	Packets_ind =NULL;
	Number_of_Packets_ind = 0;
	Packets = NULL;
	NPacketToSend = 0;
}


void McReadSocketCb(XtPointer clid, int * fd, XtInputId * input_id)
{
        int len,lend,lencur;
        unsigned char * buf;
        int ibuf = 0;           /* index in buf */
	Mcs_gotodata gotodata;
	Mcs_alldata alldata;
	McRtpGotoIdDataStruct html_goto_id_data;
	McRtpCursorPosDataStruct cursor_pos_data;
	unsigned int rtp_code;
	IPAddr ipfrom;

        len = McGetRecvBuf(&buf, &ipfrom);
        if (len <= 0 ) 
                return;

        lencur = len;
	if ( len < 16)		/* minimu rtp header for mMosaic */
		return;
	if ( ((buf[0] << 8 ) |buf[1]) != RTP_CONST_HPT_WEB) /* T:2 P:1 X:1 CC:4 M:1 PT:7 */
		return;
        while(len > ibuf){
		rtp_code = buf[ibuf+12];

#ifdef MDEBUG
			printf("len of data = %d\n",lend);
		       printf("receive from %d.%d.%d.%d\n", (ipfrom >> 24) & 0xff,
				(ipfrom >> 16) & 0xff,
				(ipfrom >> 8) & 0xff,
				(ipfrom ) & 0xff);
#endif
                switch(rtp_code){
                case MCR_ALLDATA:
			lend = McCheckAllData(&buf[ibuf],lencur, &alldata,ipfrom);
			if(!lend) return;
			ibuf += lend;
			lencur -= lend;
			McActionAllData(&alldata);
			break;
		case MCR_HEARBEAT:
			lend = McCheckAllData(&buf[ibuf],lencur, &alldata,ipfrom);
			if(!lend) return;
			ibuf += lend;
			lencur -= lend;
			McActionHearBeatData(&alldata);
			break;
		case MCR_HTML_GOTO_ID:
			lend = McCheckGotoId(&buf[ibuf],lencur, &html_goto_id_data,ipfrom);
			if(!lend) return;
			ibuf += lend;
			lencur -= lend;
			McActionGotoIdData(&html_goto_id_data);
			break;
		case MCR_CURSOR_POS:
			lend = McCheckCursorPos(&buf[ibuf],lencur, &cursor_pos_data,ipfrom);
			if(!lend) return;
			ibuf += lend;
			lencur -= lend;
			McActionCursorPosData(&cursor_pos_data);
			break;

                default:
                        fprintf(stderr,"RTPError code reading buffer\n");
                        return;
                } /* switch */
        }/* while */
}

static void McSendGotoIdTimeOutCb(XtPointer clid, XtIntervalId * id)
{
	unsigned char code;
	unsigned long gmt_send_time;
	unsigned int html_goto_id;

#ifdef MDEBUG
	printf("in McSendGotoIdTimeOutCb \n");
#endif
	mc_send_goto_id_time_out_id = XtAppAddTimeOut(
                                mMosaicAppContext,
                                MC_SEND_GOTO_ID_TIME_OUT,
                                McSendGotoIdTimeOutCb,
                                NULL);
	if (mc_data_send_data_struct.is_send == 0)
		return;	/* is it send Once ? No*/

#ifdef MDEBUG
	printf("McSendGotoIdTimeOutCb ... sending ...\n");
#endif
	code = MCR_HTML_GOTO_ID;
	gmt_send_time = McDate();

/* get the html_goto_id */

	html_goto_id = HTMLPositionToId(mc_send_win->scrolled_win, 0, 3);

        McSendRtpGotoId( code, mc_my_pid, mc_local_url_id,
              gmt_send_time, html_goto_id);

}

void McSendAllDataOnlyOnce(McSendDataStruct * d)
{
	int mask, omask;
	int i;

/* #### don't work yet #### */

#ifdef SVR4
	if( sighold(SIGUSR1) != 0){
		perror("error in sig hold: ");
	}
#else
	mask = sigmask(SIGUSR1);
	omask = sigblock(mask);
#endif

	if (d->id < mc_local_url_id){  /* ### *MUST* be based on time * fill only if it's new */
		McFillData( d,  mc_send_win);
		if(Packets){
			for(i = 0; i< NPacketToSend; i++)
				free(Packets[i].data);
			free(Packets);
		}
		Packets = NULL;
		NPacketToSend = 0;
	}
	d->id = mc_local_url_id;
	d->alias = mc_alias_name;
	d->url = mc_local_url;
	d->is_send = 0;
#ifdef MDEBUG
	printf(" in McSendAllDataTimeOutCb ... setting is_send... 0\n");
#endif
	McSendAllDataInBandWidth(d);
#ifdef SVR4
	if( sigrelse(SIGUSR1) != 0) {
		perror("error in sigrelse: ");
	}
#else
	sigsetmask(omask);
#endif
}

void McReadRtcpSocketCb(XtPointer clid, int * fd, XtInputId * input_id)
{
        int len,lend,lencur;
        unsigned char * buf;
        int ibuf = 0;           /* index in buf */
	int rtcp_code;
	int lrmp_code;
	McRtcpSdesCnameDataStruct rtcp_sdes_cname_data;
	McRtcpLrmpNackDataStruct rtcp_lrmp_nack_data;
	McRtcpLrmpNackAllDataStruct rtcp_lrmp_nack_all_data;
	McRtcpByeDataStruct rbye;
	IPAddr ipfrom;

        len = McGetRtcpRecvBuf(&buf,&ipfrom);
        if (len <= 0 ) 
                return;

        lencur = len;
        while(len > ibuf){
		if (len <= ibuf+1)
			return;
		rtcp_code = buf[ibuf+1];
                switch(rtcp_code){
		case RTCP_PT_LRMP:
			lrmp_code = buf[ibuf] & 0x1f;
			switch (lrmp_code){
			case LRMP_NACK:
				lend = McCheckRtcpLrmpNack(&buf[ibuf], lencur, &rtcp_lrmp_nack_data, ipfrom );
				if(!lend) return;
				ibuf += lend;
				lencur -= lend;
				McActionRtcpLrmpNackData(&rtcp_lrmp_nack_data);
				break;
			case LRMP_NACK_ALL:
				lend = McCheckRtcpLrmpNackAll(&buf[ibuf], lencur, &rtcp_lrmp_nack_all_data, ipfrom );
				if(!lend) return;
				ibuf += lend;
				lencur -= lend;
				McActionRtcpLrmpNackAllData(&rtcp_lrmp_nack_all_data);
				break;
			default:
				fprintf(stderr,"LRMP Error code\n");
                        	return;
			}
			break;

		case RTCP_PT_BYE:
                        lend = McCheckRtcpBye(&buf[ibuf], lencur, &rbye , ipfrom);
                        if(!lend) return;
                        ibuf += lend;
                        lencur -= lend;
                        McActionRtcpByeData(&rbye);
			printf("RTCP receive BYE.\n"); 
                        break;
                } /* switch */
        }/* while */
}


/*############################################################# */
/*fd write multicast socket ###### */

/* create the virtual cursor */
/*
	hw = (HTMLWidget) win->scrolled_win;
	fg = hw->html.foreground_SAVE;
	bg = hw->html.background_SAVE;
       	VirCursorPix = XCreatePixmapFromBitmapData (mMosaicDisplay,
                       DefaultRootWindow(mMosaicDisplay),
                       (char*)vir_cursor_bits, vir_cursor_width,
                       vir_cursor_height, fg^bg, 0, 
		DefaultDepth( mMosaicDisplay,
		              DefaultScreen( mMosaicDisplay ) 
		            ) );
	gcm = GCFunction | GCForeground | GCPlaneMask | GCBackground |
		GCSubwindowMode ;
       	gcv.function = GXxor;
       	gcv.foreground = /*fg ^ bg*/0;
       	gcv.plane_mask = AllPlanes;
       	gcv.background = 0;
	gcv.subwindow_mode = IncludeInferiors;

	gc_vc = XCreateGC(mMosaicDisplay,
			XtWindow(mMosaicToplevelWidget),gcm,&gcv);
*/
/* #### */

void McSetCursorPos(Widget w, int x, int y)
{
	HTMLWidget hw = (HTMLWidget) w;
	XCopyArea(mMosaicDisplay,VirCursorPix,XtWindow(hw->html.view),
		gc_vc,0,0,vir_cursor_width,vir_cursor_height,
		x,y);
}

#endif /* MULTICAST */
