/* sockio.c
 * Author: Gilles Dauphin
 * Version 3.1.1 [May97]
 *
 * Copyright (C) 1997 - G.Dauphin, P.Dax
 *
 * See the file "license.mMosaic" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES. 
 *
 * Bug report : dauphin@sig.enst.fr dax@inf.enst.fr
 */

#ifdef MULTICAST

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/param.h>
#include <Xm/XmAll.h>



#if defined(__QNX__) || defined(ultrix)
/* From frank@ctcqnx4.ctc.cummins.com Mon Apr 28 02:33:01 1997
/* QNX tcp/ip is not as complete, and I have to modify "libmc/mc_sockio.c"
/* to make it compile. I am wondering IP multicast is supported, I will
/* check with QNX to see ..  
/* I will let you know, maybe we will have to disable this for QNX.  */

/*those are borrowed from Linux */
/*QNX's <netinet/in.h> is far from complete, some stuffs are not supported */

#define IP_MULTICAST_TTL        0x11    /* set/get IP multicast timetolive */
#define IP_ADD_MEMBERSHIP       0x13    /* add  an IP group membership     */
/*
 * Argument structure for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP.
 */
struct ip_mreq {
        struct in_addr  imr_multiaddr;  /* IP multicast address of group */
        struct in_addr  imr_interface;  /* local IP address of interface */
};
#endif /* __QNX__ */

#include "../libnut/mipcf.h"
#include "../libhtmlw/HTML.h"
#include "../libhtmlw/HTMLP.h"
#include "../src/mosaic.h"
#include "../src/mo-www.h"

#include "mc_rtp.h"
#include "mc_defs.h"
#include "mc_misc.h"
#include "mc_sockio.h"
#include "mc_dispatch.h"

IPAddr		mc_local_ip_addr;

#ifdef IPV6 
static const IPAddr anyaddr = IPV6ADDR_ANY_INIT;
#endif  
 
#ifdef IPV6

static struct sockaddr_in6 addr_r;
static struct sockaddr_in6 rtcp_addr_r;
static struct sockaddr_in6 addr_w;
static struct sockaddr_in6 rtcp_addr_w;
#else

static struct sockaddr_in addr_r;
static struct sockaddr_in rtcp_addr_r;
static struct sockaddr_in addr_w;
static struct sockaddr_in rtcp_addr_w;
#endif

static int addr_r_len;
static int rtcp_addr_r_len;
static unsigned char emit_buf[MC_MAX_BUF_SIZE];
static unsigned char recv_buf[MC_MAX_BUF_SIZE];
static unsigned int mc_send_cnt = 0;
static unsigned int mc_my_upd_time ;

#ifdef SOLARIS
#ifdef  __cplusplus
extern "C" {
#endif

int gethostname(char *name, int namelen); /* because solaris 2.5 include bug */

#ifdef  __cplusplus
}
#endif
#endif

int McOpenRtpRead(IPAddr ip,unsigned short port,unsigned char ttl)
{
#ifdef IPV6
        struct ipv6_mreq mreq;
	struct sockaddr_in6 fakesockaddr;
#else
        struct ip_mreq mreq;
	struct sockaddr_in fakesockaddr;
#endif

        int one = 1;
	int fd=-1;
	char hostname[MAXHOSTNAMELEN];
	struct hostent *hp;
	int sd_len;
	int fakesock;

#ifdef IPV6
        if ((fd = socket(AF_INET6, SOCK_DGRAM, 0)) <0 ) {
#else
        if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) <0 ) {
#endif
                perror ("McOpenRead: socket");
                exit(1);
        }
        /* so that more than one process can bind to the same
           SOCK_DGRAM UDP port ( must be placed BEFORE bind() ) */
        if(setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&one, sizeof(one))){
		perror ("McOpenRead: setsockopt SO_REUSEADDR");
		exit(1);
	}
	addr_r_len = sizeof(addr_r);
        memset(&addr_r,0,sizeof(addr_r));
#ifdef IPV6
        addr_r.sin6_family = AF_INET6;
        addr_r.sin6_port = port;
        addr_r.sin6_addr = anyaddr;
#else
        addr_r.sin_family = AF_INET;
        /*addr_r.sin_port = htons(port);*/
        addr_r.sin_port = port;
        addr_r.sin_addr.s_addr = htonl(INADDR_ANY);
#endif
        if(bind(fd, (struct sockaddr *)&addr_r, sizeof(addr_r)) <0) {
                perror ("McOpenRead: bind:");
                exit(1);
        }
#ifdef IPV6
        mreq.ipv6mr_multiaddr = ip;
        mreq.ipv6mr_interface = anyaddr;
        if (setsockopt(fd, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP,
#else
        /*mreq.imr_multiaddr.s_addr = htonl(ip);*/
        mreq.imr_multiaddr.s_addr = ip;
        mreq.imr_interface.s_addr = htonl(INADDR_ANY);
        if (setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP,
#endif

            (char *)&mreq, sizeof(mreq)) < 0) {
                perror ("McOpenRead: setsockopt IP_ADD_MEMBERSHIP:");
                exit(1);
        }

#ifdef IPV6
        /* This bogosity is to find the IP address of the local host! */
        if ((fakesock = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
                perror("socket");
                exit(1);
        }
        if ( gethostname(hostname, MAXHOSTNAMELEN) != 0) {
                perror("McOpenRead: gethostname " );
                exit(1);
        }
/*        hp = gethostbyname2(hostname,AF_INET6); */
        hp = hostname2addr(hostname,AF_INET6);
	if (!hp) {
                fprintf(stderr,"IPV6 gasp no hosts \n");
                exit(1) ;
        }
        memcpy((char *)&fakesockaddr.sin6_addr, hp->h_addr, hp->h_length);
        fakesockaddr.sin6_port = 0;
        bind(fakesock, (struct sockaddr *) &fakesockaddr, sizeof(fakesockaddr));
        sd_len = sizeof(fakesockaddr);
        getsockname(fakesock, (struct sockaddr *)&fakesockaddr, &sd_len);
        mc_local_ip_addr = fakesockaddr.sin6_addr;
        close(fakesock);
#else
        /* This bogosity is to find the IP address of the local host! */
        if ((fakesock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
                perror("socket");
                exit(1);
        }
        if ( gethostname(hostname, MAXHOSTNAMELEN) != 0) {
                perror("McOpenRead: gethostname " );
                exit(1);
        }
        hp = gethostbyname(hostname);
        memcpy((char *)&fakesockaddr.sin_addr, hp->h_addr, hp->h_length);
        fakesockaddr.sin_port = htons(0);
        bind(fakesock, (struct sockaddr *) &fakesockaddr, sizeof(fakesockaddr));
        sd_len = sizeof(fakesockaddr);
        getsockname(fakesock, (struct sockaddr *)&fakesockaddr, &sd_len);
        mc_local_ip_addr = ntohl(fakesockaddr.sin_addr.s_addr);
        close(fakesock);
#endif

	return fd;
}

int McOpenRtcpRead (IPAddr ip,unsigned short port,unsigned char ttl)
{
#ifdef IPV6     
        struct ipv6_mreq mreq;
        struct sockaddr_in6 fakesockaddr;
#else
        struct ip_mreq mreq;
        struct sockaddr_in fakesockaddr;
#endif 
        int one = 1;
	int fd=-1;
	char hostname[MAXHOSTNAMELEN];
	struct hostent *hp;
	int sd_len;
	int fakesock;

#ifdef IPV6
        if ((fd = socket(AF_INET6, SOCK_DGRAM, 0)) <0 ) {
#else                                 
        if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) <0 ) {
#endif
                perror ("McOpenRtcpRead: socket");
                exit(1);
        }
        /* so that more than one process can bind to the same
           SOCK_DGRAM UDP port ( must be placed BEFORE bind() ) */
        if(setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&one, sizeof(one))){
		perror ("McOpenRtcpRead: setsockopt SO_REUSEADDR");
		exit(1);
	}
	rtcp_addr_r_len = sizeof(rtcp_addr_r);
        memset(&rtcp_addr_r,0,sizeof(rtcp_addr_r));
#ifdef IPV6                           
        rtcp_addr_r.sin6_family = AF_INET6;
        rtcp_addr_r.sin6_port = port;      
        rtcp_addr_r.sin6_addr = anyaddr;   
#else                                 
        rtcp_addr_r.sin_family = AF_INET;
        /*addr_r.sin_port = htons(port);*/
        rtcp_addr_r.sin_port = port;
        rtcp_addr_r.sin_addr.s_addr = htonl(INADDR_ANY);
#endif
        if(bind(fd, (struct sockaddr *)&rtcp_addr_r, sizeof(rtcp_addr_r)) <0) {
                perror ("McOpenrtcp_Read: bind:");
                exit(1);
        }
#ifdef IPV6                           
        mreq.ipv6mr_multiaddr = ip;   
        mreq.ipv6mr_interface = anyaddr;
        if (setsockopt(fd, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP,
#else                                 
        /*mreq.imr_multiaddr.s_addr = htonl(ip);*/
        mreq.imr_multiaddr.s_addr = ip;
        mreq.imr_interface.s_addr = htonl(INADDR_ANY);
        if (setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP,
#endif
            (char *)&mreq, sizeof(mreq)) < 0) {
                perror ("McOpenrtcp_Read: setsockopt IP_ADD_MEMBERSHIP:");
                exit(1);
        }

#ifdef IPV6                           
        /* This bogosity is to find the IP address of the local host! */
        if ((fakesock = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
                perror("socket");     
                exit(1);              
        }                             
        if ( gethostname(hostname, MAXHOSTNAMELEN) != 0) {
                perror("McOpenRead: gethostname " );
                exit(1);              
        }                             
/*        hp = gethostbyname2(hostname,AF_INET6); */
        hp = hostname2addr(hostname,AF_INET6);
        if (!hp) {                    
                fprintf(stderr,"IPV6 gasp no hosts \n");
                exit(1) ;             
        }                             
        memcpy((char *)&fakesockaddr.sin6_addr, hp->h_addr, hp->h_length);
        fakesockaddr.sin6_port = 0;  
        bind(fakesock, (struct sockaddr *) &fakesockaddr, sizeof(fakesockaddr));
        sd_len = sizeof(fakesockaddr);
        getsockname(fakesock, (struct sockaddr *)&fakesockaddr, &sd_len);
        mc_local_ip_addr = fakesockaddr.sin6_addr;
        close(fakesock);              
#else
        /* This bogosity is to find the IP address of the local host! */
        if ((fakesock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
                perror("socket");
                exit(1);
        }
        if ( gethostname(hostname, MAXHOSTNAMELEN) != 0) {
                perror("McOpenrtcp_Read: gethostname " );
                exit(1);
        }
        hp = gethostbyname(hostname);
        memcpy((char *)&fakesockaddr.sin_addr, hp->h_addr, hp->h_length);
        fakesockaddr.sin_port = htons(0);
        bind(fakesock, (struct sockaddr *) &fakesockaddr, sizeof(fakesockaddr));
        sd_len = sizeof(fakesockaddr);
        getsockname(fakesock, (struct sockaddr *)&fakesockaddr, &sd_len);
        mc_local_ip_addr = ntohl(fakesockaddr.sin_addr.s_addr);
        close(fakesock);
#endif
	return fd;
}

int McOpenRtpWrite(IPAddr ip,unsigned short port,unsigned char ttl)
{
	int fd;
	unsigned int t6 = ttl;
 
#ifdef IPV6
	fd = socket(AF_INET6, SOCK_DGRAM, 0);
#else
	fd = socket(AF_INET, SOCK_DGRAM, 0);
#endif
	if(fd<0) {
		perror("McOpenWrite: socket");
		exit(1);
	}  
#ifdef IPV6
	if (setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
		       (char*)&(t6), sizeof(t6)) < 0) {
		perror("McOpenWrite:setsockopt IP_MULTICAST_HOPS:");
		exit(1);
	}
	memset(&addr_w,0,sizeof(addr_w));
	addr_w.sin6_family = AF_INET6;
	addr_w.sin6_port = port;
	addr_w.sin6_addr = ip;
#else
	if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL,
		       (char*)&(ttl), sizeof(ttl)) < 0) {
		perror("McOpenWrite:setsockopt IP_MULTICAST_TTL:");
		exit(1);
	}
	memset(&addr_w,0,sizeof(addr_w));
	addr_w.sin_family = AF_INET;
	addr_w.sin_port = port;
	addr_w.sin_addr.s_addr = ip;
#endif
	return fd;
}

int McOpenRtcpWrite(IPAddr ip,unsigned short port,unsigned char ttl)
{
	int fd;
	unsigned int t6 = ttl; 
#ifdef IPV6
	fd = socket(AF_INET6, SOCK_DGRAM, 0);
#else
	fd = socket(PF_INET, SOCK_DGRAM, 0);
#endif
	if(fd<0) {
		perror("McOpenRtcpWrite: socket");
		exit(1);
	}  
#ifdef IPV6
	if (setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
		       (char*)&(t6), sizeof(t6)) < 0) {
		perror("McOpenRtcpWrite:setsockopt IP_MULTICAST_HOPS:");
		exit(1);
	}
	memset(&rtcp_addr_w,0,sizeof(rtcp_addr_w));
	rtcp_addr_w.sin6_family = AF_INET6;
	rtcp_addr_w.sin6_port = port;
	rtcp_addr_w.sin6_addr = ip;
#else
	if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL,
		       (char*)&(ttl), sizeof(ttl)) < 0) {
		perror("McOpenRtcpWrite:setsockopt IP_MULTICAST_TTL:");
		exit(1);
	}
	memset(&rtcp_addr_w,0,sizeof(rtcp_addr_w));
	rtcp_addr_w.sin_family = AF_INET;
	rtcp_addr_w.sin_port = port;
	rtcp_addr_w.sin_addr.s_addr = ip;
#endif
	return fd;
}

/*
 * return number of byte read and the static recv_buf 
 */
int McGetRecvBuf(unsigned char ** buf, IPAddr * ipfrom)
{
	int cnt;
  
	cnt = recvfrom(mc_fdread, (char*)recv_buf, MC_MAX_BUF_SIZE,0, 
			(struct sockaddr *)&addr_r, &addr_r_len);
	if (cnt <= 0 ) {
		printf("error in McGetRecvBuf\n");
		perror ("recvfrom");
		/* exit(1); */
	}
	*buf = recv_buf;
#ifdef IPV6
	*ipfrom = addr_r.sin6_addr;
#else
	*ipfrom = addr_r.sin_addr.s_addr;
#endif
#ifdef MDEBUG
	printf("McGetRecvBuf: cnt=%d, recv_buf[12]=%ud\n",cnt,recv_buf[12]);
#endif
	return cnt;
}

/* return the number of byte read or 0 if probleme */

int McCheckCursorPos( unsigned char *buf, int len_buf, McRtpCursorPosDataStruct *cp, IPAddr ipfrom)
{
	unsigned int i;
	unsigned char * p = buf;

/*################## this code need to be revisited #### unuse padding*/
	if ( len_buf < (17+3) ){ 
		fprintf(stderr,"Error receiving CURSOR_POS: n = %d\n", len_buf);
		return 0;
	}

			/* T:2 P:1 X:1 CC:4 M:1 PT:7 */
	cp->rh_flags = (u_int16_t) (	((unsigned long) p[0] << 8 ) |
                                                ((unsigned long) p[1]      ) );

	if (cp->rh_flags != (u_int16_t) RTP_CONST_HPT_WEB){
		fprintf(stderr,"Error receiving CURSOR_POS: proto error\n");
		return 0;
	}
	cp->url_id =  (u_int32_t) (	((unsigned long) p[9] << 16)|
						((unsigned long) p[2] << 8) |
						((unsigned long) p[3]      ));
	cp->gmt_send_time=(u_int32_t)(     ((unsigned long) p[4] << 24) |
					        ((unsigned long) p[5] << 16) |
					        ((unsigned long) p[6] << 8 ) |
					        ((unsigned long) p[7]      ) );
	cp->ipaddr = 	ipfrom;

	cp->ssrc = (u_int8_t)	p[8];
	cp->pid =  (u_int16_t)(            ((unsigned long) p[10] << 8 ) |
					        ((unsigned long) p[11]      ) );
	cp->code = (u_int8_t)	p[12];

	cp->posx = (int16_t) (			((unsigned long) p[13] << 8) |
					        ((unsigned long) p[14] ) );
	cp->posy = (int16_t) (			((unsigned long) p[15] << 8) |
					        ((unsigned long) p[16] ) );
 
/*################## this code need to be revisited #### unuse padding*/
	return 17 +3;
}

/* return the number of byte read or 0 if probleme */

void McSendRtpCursorPos( unsigned char code, unsigned short pid, 
	unsigned int url_id, unsigned int gmt_send_time,
	int x, int y)
{
	unsigned int len_buf;

	emit_buf[0] = (RTP_CONST_HPT_WEB >> 8) & 0xff;	/* web header*/
	emit_buf[1] = RTP_CONST_HPT_WEB & 0xff;

	emit_buf[9] = (url_id >> 16) & 0xff;		/* url_id */
	emit_buf[2] = (url_id >> 8) & 0xff;
	emit_buf[3] =  url_id & 0xff;

	emit_buf[4] =  (gmt_send_time >> 24) & 0xff;    /* MSB gmt_send_time */
	emit_buf[5] = (gmt_send_time >> 16) & 0xff;
	emit_buf[6] = (gmt_send_time >> 8) & 0xff;
	emit_buf[7] =  gmt_send_time & 0xff;

	emit_buf[8] = 0x01;

	emit_buf[10] = (pid >> 8) & 0xff; 	/* MSB pid */
	emit_buf[11] = pid & 0xff;

	emit_buf[12] = code ;			/* code */

	emit_buf[13] = (x >> 8) & 0xff; 
	emit_buf[14] = x & 0xff;
	emit_buf[15] = (y >> 8) & 0xff; 
	emit_buf[16] = y & 0xff;

/*################## this code need to be revisited #### unuse padding*/
	emit_buf[17] = emit_buf[18] = emit_buf[19] =0;
	len_buf = 17 + 3;
        McSendData(emit_buf, len_buf);
}


static IPAddr current_nack_uip_addr;
static unsigned int current_nack_upid;
static unsigned int current_nack_uurl_id;
static unsigned int current_nack_num_eo;
static unsigned int current_nack_ussrc;
static int packet_tab[17];
static int nombre_packet=0;

/*
 * return number of byte read and the static recv_buf 
 */
int McGetRtcpRecvBuf(unsigned char ** buf, IPAddr * ipfrom)
{
	int cnt;
  
	cnt = recvfrom(mc_rtcp_fdread, (char*)recv_buf, MC_MAX_BUF_SIZE,0, 
			(struct sockaddr *)&rtcp_addr_r, &rtcp_addr_r_len);
	if (cnt <= 0 ) {
		perror ("recvfrom");
		/* exit(1); */
	}
	*buf = recv_buf;
#ifdef IPV6
	*ipfrom = rtcp_addr_r.sin6_addr;
#else
	*ipfrom = rtcp_addr_r.sin_addr.s_addr;
#endif
	return cnt;
}

#endif /* MULTICAST */
