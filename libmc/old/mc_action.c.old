/* mc_action.c */

#ifdef MULTICAST

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <ctype.h>
#include <sys/utsname.h>
#include <pwd.h>
#include <Xm/XmAll.h>
#include <signal.h>

#include "../libnut/mipcf.h"
#include "../libhtmlw/HTML.h"
#include "../libhtmlw/HTMLP.h"
#include "../src/mosaic.h"
#include "../src/gui.h"
#include "../src/gui-documents.h"

#include "mc_rtp.h"
#include "mc_defs.h"
#include "mc_misc.h"
#include "mc_sockio.h"
#include "mc_dispatch.h"
#include "mc_action.h"

#define CLIP_TRAILING_NEWLINE(url) \
  if (url[strlen (url) - 1] == '\n') \
    url[strlen (url) - 1] = '\0';

IPAddr  	mc_addr_ip_group;
unsigned short 	mc_port;
unsigned short 	mc_rtcp_port;
time_t 		mc_init_gmt;
unsigned short 	mc_my_pid;
time_t 		mc_init_local_time;


McUserList mc_ulist=NULL;

Widget mc_list_top_w = NULL;
Widget mc_list_main_rc_w = NULL;

typedef struct _mc_w_u_lst {
	Widget form;
	Widget toggle;
	Widget label;
	McUser * user;
/*	mo_window * win; */
} McWULst;

McWULst * mc_wulst;
int mc_wulst_cnt = 0;


/*########### remove the user too #########*/

/* When click again on user in member list. I don't want listen to this
 * user. So remove the user's mo_window */
/* ##### c'est a faire... ##### */
void McRemoveMoWin(McUser * u)
{
	mo_window *win;
	mo_node *node ;

	win = u->win;

	if(win)
		mo_delete_window(win);
	u->win = NULL;
	u->rcv_enable = 0;
	ClearRcvData(u);
	XtVaSetValues(mc_wulst[u->mc_list_number].toggle,
				XmNset, False,
				NULL);
	
}

void McDeleteUser(McUser *u, int i)
{
        McUser * uu;
	int j;
	int nuu;

	XtDestroyWidget(mc_wulst[u->mc_list_number].form);
	if ((u->prev == NULL) && (u->next == NULL)){
		mc_ulist = NULL;
		free(u);
	} else if (u->prev == NULL){
		mc_ulist = u->next;
		mc_ulist->prev = NULL;
		free(u);
	} else if (u->next == NULL){
		u->prev->next = NULL;
		free(u);
	} else {
		u->prev->next = u->next;
		u->next->prev = u->prev;
		free(u);
	}
		
	for(j=i+1; j < mc_wulst_cnt; j++){
		uu = mc_wulst[j].user;
		nuu = uu->mc_list_number;
		mc_wulst[j-1] = mc_wulst[j];
		uu->mc_list_number = nuu - 1;
	}
	mc_wulst_cnt-- ;
}
 

/*
 * Bye: Un participant quite.
 */
void McActionRtcpByeData(McRtcpByeDataStruct * rbye)
{
	unsigned int i;
	McUser * user;

	/* Process a directive that we received by multicast. */
	mo_window *win;
        unsigned int ugmts;
        IPAddr uip_addr;
        unsigned short upid;
	char * tmp;
	time_t t;
	int u_is_upd = 0;


        if(ADDRCMP(rbye->ipaddr, mc_local_ip_addr) && (rbye->pid==mc_my_pid)){
#ifdef MDEBUG
		printf("McActionBye: It's Me\n");
#endif
                return;			/* It's Me */
	}
	user = SolveUser(uip_addr,upid);	/* get user struct*/
	if (user == NULL){
		return;
	}
	t = time(NULL);
	win = user->win;
	if(win) 
		McRemoveMoWin(user);
	McDeleteUser(user, user->mc_list_number);
}
/* cyclique check if rcv is alive */
 
void McCheckRcvstimeTimeOutCb(XtPointer clid, XtIntervalId * id)
{       
        McUser * u;
        time_t t;
        int i;

        t = time(NULL);
        
        for(i = 1; i<mc_wulst_cnt; i++){ /* start at 1 . # 0 is Me */
                u = mc_wulst[i].user;
                if( (t - u->last_rcv_time) > (MC_CHECK_RCVSTIME_TIME_OUT/1000)){
                        /* remove the member */
                        if(u->win) 
                                McRemoveMoWin(u); 
			McDeleteUser(u, i);
                }
        }
	mc_check_rcvstime_time_out_id = XtAppAddTimeOut(
		mMosaicAppContext,
		MC_CHECK_RCVSTIME_TIME_OUT,
		McCheckRcvstimeTimeOutCb,
		NULL);
}                                      
                                       
/* cyclique check if member is alive as sender */
                                       
void McCheckSenderstimeTimeOutCb(XtPointer clid, XtIntervalId * id)
{                                      
        McUser * u;
        time_t t; 
	int i;
 
        t = time(NULL); 
 
        for(i = 1; i<mc_wulst_cnt; i++){
                u = mc_wulst[i].user;
                if (u->url_id == 0) continue; 
                if( (t - u->last_sender_time) > (MC_CHECK_SENDERSTIME_TIME_OUT/1000)){
                        /* the sender member become a reveiver */ 
                        if(u->win) 
                                McRemoveMoWin(u); 
                        u->url[0] = '\0'; 
                        XmxAdjustLabelText(mc_wulst[u->mc_list_number].label,u->url);                     
                } 
        }
	mc_check_senderstime_time_out_id = XtAppAddTimeOut(
		mMosaicAppContext,
		MC_CHECK_SENDERSTIME_TIME_OUT,
		McCheckSenderstimeTimeOutCb,
		NULL); 
}   

void McCreateMoWin(McUser * u)
{
	mo_window * win;
	mo_node *node ;

	win = mo_make_window(NULL, MC_MO_TYPE_RCV_ALL);
/*	node= (mo_node *)malloc (sizeof (mo_node)); */
/*	node->title=NULL;	*/
/*	node->url=NULL;     /* c'est l'url de reference sous forme canonique*/
/*	node->last_modified=NULL;
	node->expires=NULL;
	node->ref=NULL;
	node->text=NULL;
	node->position=0;
	node->annotation_type=0;
	node->docid=1;
	node->cached_stuff=NULL;
	node->authType=0;
	node->previous=NULL;
	node->next=NULL;
*/
#ifdef TO_DO
/* ...faut comprendre ce que ca fait tous ces champs... */
/* node-> char *title; */
/* node-> char *last_modified; */
/* node-> char *expires; */
/* node-> char *ref; */
/* node-> char *text; */
/* node-> int position; */
/* node-> int docid; */
/* node-> void *cached_stuff; */
/* node-> int authType; */
#endif
}

void PopUpOrDownMosaicMcUser(Widget w, XtPointer clid, XtPointer calld)
{
	McUser * u = (McUser *) clid;

	if (u->rcv_enable == 0) {	/* create an mo_window for user */
		McCreateMoWin(u);
		u->rcv_enable = 1;
	} else {			/* delete the user's mo_window */
		McRemoveMoWin(u);
	}
}

void McInitUser( McUser * u)
{
        u->url[0] = '\0';
        u->url_id = 0;
        u->last_rcv_time = u->last_sender_time = 0;
        u->player_goto_time = 0;
        u->my_goto_time = 0;
        u->player_fdata_time = 0;
        u->my_fdata_time = 0;
        u->len_alias = 0;
        u->alias[0] = '\0';
        u->mc_list_number = -1;
        u->rcv_enable = 0;
        u->text = NULL;
        u->neo = 0;
        u->seo = NULL;
        u->eos = NULL;
	u->filename = NULL;
        u->pds = NULL;
        u->win = NULL;
	u->oldx = -100;
	u->oldy = -100;
	u->next = NULL;
	u->prev = NULL;
}

static McUser * SolveUser(IPAddr uip_addr, unsigned short upid)
{
#ifdef IPV6
	sprintf(user->alias,"Unknow@ipv6.domain");
#else
	sprintf(user->alias,"Unknow@%d.%d.%d.%d",
		(uip_addr >> 24) & 0xFF, (uip_addr >> 16) & 0xFF,
		(uip_addr >> 8 ) & 0xFF, uip_addr & 0xFF);
#endif
}

/*
 * C'est pareil que McActionAllData, sauf qu'on a que le premier
 * packet (Packets[0]). C'est comme si on perd tous les autres
 * il va falloir demander les packets manquants (voir LRMP)
 */
void McActionHearBeatData(Mcs_alldata* alldata)
{
	unsigned int i,j, num_eo,seo,nombre_packet,num_packet,len_data;
	char * data;
	McUser * user;

	/* Process a directive that we received by multicast. */
        if(ADDRCMP(alldata->ipaddr, mc_local_ip_addr) && (alldata->pid==mc_my_pid))
                 return;                        /* It's Me */
	ugmts = alldata->gmt_send_time;
	uurl_id = alldata->url_id;
	uip_addr = alldata->ipaddr;
	upid =  alldata->pid;
	ussrc = alldata->ssrc;
	user = SolveUser(uip_addr,upid);	/* get user struct*/
	/* We know on Unix system that ip_addr/pid is unique in World */
	/* So the url_id can only grown up */

	if((user->url_id < alldata->url_id) && 	/* a new text  */
	   user->rcv_enable)
		ClearRcvData(user);		/*clean the struct & free block */

	/* now fill the 'user' structure with the 'alldata' struct */

	t = time(NULL);
	user->url_id = alldata->url_id;
        user->last_rcv_time = user->last_sender_time = t; /* Last time i hear him */
	user->my_fdata_time = t;   	/* Last msg rcv by this user*/
	user->player_fdata_time = alldata->gmt_send_time;/* Player last upd gmt*/
}

/*
 * affiche l' hypertexte dans la fenetre idoine
 */
void McActionAllData(Mcs_alldata* alldata)
{
	unsigned int i, num_eo,seo,nombre_packet,num_packet,len_data;
	char * data;
	McUser * user;
	mo_window *win;
        unsigned int ugmts;
        unsigned int uurl_id;
        IPAddr  uip_addr;
        unsigned short upid;
	char * tmp;
	time_t t;
	int u_is_upd = 0;

/* Process a directive that we received by multicast. */
        if(ADDRCMP(alldata->ipaddr, mc_local_ip_addr) && (alldata->pid==mc_my_pid))
                 return;			/* It's Me */
	ugmts = alldata->gmt_send_time;
	uurl_id = alldata->url_id;
	uip_addr = alldata->ipaddr;
	upid =  alldata->pid;
	user = SolveUser(uip_addr,upid);	/* get user struct*/
	/* We know on Unix system that ip_addr/pid is unique in World */
	/* So the url_id can only grown up */
	if((user->url_id < alldata->url_id) && 	/* a new text  */
	   user->rcv_enable)
		ClearRcvData(user);		/*clean the struct & free block */
	/* now fill the 'user' structure with the 'alldata' struct */
	t = time(NULL);
	user->url_id = alldata->url_id;
        user->last_rcv_time = user->last_sender_time = t;/*Last time i hear him */
	user->my_fdata_time = t;   	/* Last msg rcv by this user*/
	user->player_fdata_time = alldata->gmt_send_time;/* Player last upd gmt*/

	if(user->url[0] == '\0'){
		strcpy(user->url,"Url Path Not Available Yet");
		u_is_upd++;
	}
	num_eo = alldata->num_eo;
	win = user->win;		/* la mo_window du user */
	if(user->neo == 0){	/* allocate space in 'user'*/
}

/*
 * CursorPosition: change la position du curseur virtuel
 */
void McActionCursorPosData(McRtpCursorPosDataStruct * cp)
{
	unsigned int i;
	McUser * user;

	/* Process a directive that we received by multicast. */
	mo_window *win;
        unsigned int ugmts;
        IPAddr uip_addr;
        unsigned short upid;
	char * tmp;
	time_t t;
	int u_is_upd = 0;


        if(ADDRCMP(cp->ipaddr, mc_local_ip_addr) && (cp->pid==mc_my_pid)){
#ifdef MDEBUG
		printf("McActionCursorPosData: It's Me\n");
#endif
                return;			/* It's Me */
	}
	uip_addr = cp->ipaddr;
	upid =  cp->pid;
	user = SolveUser(uip_addr,upid);	/* get user struct*/
	if (user == NULL){
		fprintf(stderr,"McActionCursorPosData: PB getting user\n");
		return;
	}
	/* We know on Unix system that ip_addr/pid is unique in World */

	t = time(NULL);
        user->last_rcv_time= user->last_sender_time = t; /*Last time i hear him */
	if (!user->rcv_enable) return;
	win = user->win;
	if(!win) return;

	if((user->url_id != cp->url_id) && 	/* a new text  */
	   user->rcv_enable)
		return;
	if ( user->eos[1] == NULL ) { /* need to have the text before */
		return;
	}
/* now position the virtual cursor */
	McSetCursorPos(win->scrolled_win, user->oldx, user->oldy);
	McSetCursorPos(win->scrolled_win, cp->posx, cp->posy);
	user->oldx = cp->posx;
	user->oldy = cp->posy;
}

/*
 * GotoId: change la valeur de la scrollbar et place le texte
 */
void McActionGotoIdData(McRtpGotoIdDataStruct * hgid)
{
	unsigned int i;
	McUser * user;

	/* Process a directive that we received by multicast. */
	mo_window *win;
        unsigned int ugmts;
        IPAddr uip_addr;
        unsigned short upid;
	char * tmp;
	time_t t;
	int u_is_upd = 0;


        if(ADDRCMP(hgid->ipaddr, mc_local_ip_addr) && (hgid->pid==mc_my_pid)){
#ifdef MDEBUG
		printf("McActionGotoIdData: It's Me\n");
#endif
                return;			/* It's Me */
	}
	uip_addr = hgid->ipaddr;
	upid =  hgid->pid;
	user = SolveUser(uip_addr,upid);	/* get user struct*/
	if (user == NULL){
		fprintf(stderr,"McActionGotoIdData: PB getting user\n");
		return;
	}
	/* We know on Unix system that ip_addr/pid is unique in World */

	t = time(NULL);
        user->last_rcv_time= user->last_sender_time = t; /*Last time i hear him */
	if (!user->rcv_enable) return;
	win = user->win;
	if(!win) return;

	if((user->url_id != hgid->url_id) && 	/* a new text  */
	   user->rcv_enable)
		return;
	if ( user->eos[1] == NULL ) { /* need to have the text before */
		return;
	}
/* now goto */
	HTMLGotoId(win->scrolled_win, hgid->html_goto_id,0);
}

void McActionRtcpLrmpNackAllData(McRtcpLrmpNackAllDataStruct * rlnad)
{
        IPAddr  uip_addr;
	IPAddr6 s_uip_addr;
	unsigned int i;
	char * data;
	McUser * user;
        int mask, omask;
	mo_window *win;
        unsigned int ugmts;
        unsigned short upid;
	char * tmp;
	time_t t;
	unsigned int r_url_id,r_num_eo;
	unsigned int s_upid;

        if(ADDRCMP(rlnad->ipaddr, mc_local_ip_addr) && (rlnad->pid==mc_my_pid)){
                return;			/* It's Me */
	}
#ifdef IPV6
	if( !(ADDRCMP(rlnad->s_ipaddr, mc_local_ip_addr) && ( rlnad->s_pid == mc_my_pid)) ){ /* this NACK is not for me */
		return;
	}
#else
	if( !(ADDRCMP64(rlnad->s_ipaddr, mc_local_ip_addr) && ( rlnad->s_pid == mc_my_pid)) ){ /* this NACK is not for me */
		return;
	}
#endif
	uip_addr = rlnad->ipaddr;
	upid =  rlnad->pid;
	s_uip_addr = rlnad->s_ipaddr;
	s_upid =  rlnad->s_pid;
	
	user = SolveUser(uip_addr,upid);	/* get user struct*/
	if (user == NULL){
		fprintf(stderr,"McActionRtcpLrmpNackAllData: PB getting user\n");
		return;
	}
	/* We know on Unix system that ip_addr/pid is unique in World */
	/* now fill the 'user' structure with the 'rscd' struct */

	t = time(NULL);
        user->last_rcv_time = t;   		/* Last time i hear him */

	r_url_id = rlnad->url_id;
	r_num_eo = rlnad->num_eo;

/* sigblock critical section */

#ifdef SVR4
        if( sighold(SIGUSR1) != 0){
                perror("error in sig hold: ");
        }
#else
        mask = sigmask(SIGUSR1);
        omask = sigblock(mask);
#endif
	if ((r_url_id != mc_local_url_id) || (mc_data_send_data_struct.id !=r_url_id) ){
#ifdef SVR4
	        if( sigrelse(SIGUSR1) != 0) {
                	perror("error in sigrelse: ");
        	}
#else
        	sigsetmask(omask);      
#endif 
		return;
	}

	McSendFastAllEoData(r_num_eo);

#ifdef SVR4
        if( sigrelse(SIGUSR1) != 0) {
                perror("error in sigrelse: ");
        }
#else
        sigsetmask(omask);      
#endif 
}
void McActionRtcpLrmpNackData(McRtcpLrmpNackDataStruct * rlnd)
{
        IPAddr uip_addr;
	IPAddr6 s_uip_addr;
	unsigned int i;
	char * data;
	McUser * user;
        int mask, omask;

	/* Process a directive that we received by multicast. */
	mo_window *win;
        unsigned int ugmts;
        unsigned short upid;
	char * tmp;
	time_t t;
	unsigned int r_url_id,r_num_eo,r_fpno;
	unsigned int s_upid;
	unsigned int r_blp;

        if(ADDRCMP(rlnd->ipaddr, mc_local_ip_addr) && (rlnd->pid==mc_my_pid)){
                return;			/* It's Me */
	}
#ifdef IPV6
	if( !(ADDRCMP(rlnd->s_ipaddr, mc_local_ip_addr) && ( rlnd->s_pid == mc_my_pid)) ){ /* this NACK is not for me */
		return;
	}
#else
	if( !(ADDRCMP64(rlnd->s_ipaddr, mc_local_ip_addr) && ( rlnd->s_pid == mc_my_pid)) ){ /* this NACK is not for me */
		return;
	}
#endif
	uip_addr = rlnd->ipaddr;
	upid =  rlnd->pid;
	s_uip_addr = rlnd->s_ipaddr;
	s_upid =  rlnd->s_pid;
	
	user = SolveUser(uip_addr,upid);	/* get user struct*/
	if (user == NULL){
		fprintf(stderr,"McActionRtcpLrmpNackData: PB getting user\n");
		return;
	}
	/* We know on Unix system that ip_addr/pid is unique in World */
	/* now fill the 'user' structure with the 'rscd' struct */

	t = time(NULL);
        user->last_rcv_time = t;   		/* Last time i hear him */

	r_url_id = rlnd->url_id;
	r_num_eo = rlnd->num_eo;
	r_fpno = rlnd->fpno;
	r_blp = rlnd->blp & 0x0000ffff;

/* sigblock critical section */

#ifdef SVR4
        if( sighold(SIGUSR1) != 0){
                perror("error in sig hold: ");
        }
#else
        mask = sigmask(SIGUSR1);
        omask = sigblock(mask);
#endif
	if ((r_url_id != mc_local_url_id) || (mc_data_send_data_struct.id !=r_url_id) ){
#ifdef SVR4
	        if( sigrelse(SIGUSR1) != 0) {
                	perror("error in sigrelse: ");
        	}
#else
        	sigsetmask(omask);      
#endif 
		return;
	}

	McSendFastPacketEoData(r_num_eo,r_fpno);
	while(r_blp){
		r_fpno++;
		if ( (r_blp & 0x0001) ){
			McSendFastPacketEoData(r_num_eo,r_fpno);
		}
		r_blp = r_blp >> 1;
	}

#ifdef SVR4
        if( sigrelse(SIGUSR1) != 0) {
                perror("error in sigrelse: ");
        }
#else
        sigsetmask(omask);      
#endif 
}

#endif /* MULTICAST */
